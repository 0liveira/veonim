0.9.0 observations:
- help files missing

-- add documentation about guifont/size/cursor/colorscheme/roboto/etc


-- divination:
  - do not create label/jump coordinates for position:
    - search highlight under the cursor
  * [maybe] line jump: anchor labels to first char in the line? how to?
    - call getVisibleLines, find the first non-space char, count how many columns in the first char is in
    - return [row, col][] list map


-- buffer-search: spaces to further filter query (just like fuzzy file finder?)
  - if only one result in list and i hit enter, jump to the first result
  - actually should this be behavior even if there are more than one result? if hit enter, select first and jump to it (even if not selected_
      - i feel like i might want this in a few different places.
      - can create generic fn to use anywhere?
      - collect & show line numbers?
  - use current visual selection as input - see: helm-swoop


=== 0.10.0 release here


-- c-o/i but for files only. don't want to jump to previous location in the same file. i want to
  go to previous file kthx


-- hide overlays (problem info, hover) on bufleave
  - happens when switch tabs


-- terminal change title to current running process


-- fancy git-branch switcher


-- create overlay menu window with key shortcuts so users can create spacemacs-like
menus. e.g. (floating windows maybe?)
- press and hold a key to open up menu. next key press while key is being held will trigger action
- press key to bring up menu. next key selects an action from the menu
  [ a: buffer search    b: grep search    c: viewport-search ]
  [ d: file search                                           ]

  press and hold mark ' keybind to bring up menu of current global marks
  menu lists something like
  a - support.ts
  s - utils.ts
  d - main.ts

  pressing one of the keys takes you to that file
  releasing mark keybind closes menu without any navigation
    - no, i dont want to hold keybind. long keybind hold activates menu. esc closes it
(think kinda like opie addon, but hold activate)


-- separate out internal object data from langserv params data?
  - right now in adapter we send both vim state object and params in the same
  parameter, same object. i think it might be cleaner to send them separately,
  so that we do not send internal data to the lang serv. this may have a
neglible benefit on network (de)serializing (and xmit time?)
  - i almost feel that there is not much of a good reason to pass in the entire
  neovim state to every single langserv request ever. why can't adapter simply
  access the neovim state and pick out the nvim state fields it needs to know?


-- simliar to the key timeouts, maybe we can make key triggers after a certain amount
  of key-down holding. e.g. press/release m immediatly and it takes you to a mark.
  press and hold m and a mark menu shows up


-- langserv 3.6.0+ features
  - goto implementation
  - goto type definitions
  - others


-- INVENTORY
  - also add window commands. especially ones that i can't remember (swap, maximize/zoom, etc.)

-- show marks visually in editor?
  - if the current viewport has any marks, render them over the text.
  - i'm not sure how useful this will be, as i've used marks-in-sign column plugin before and i was not impressed. usually most marks are outside of the current viewport. would need a better way to visually indicate those

-- better window management
  - divination jump labels for jumping to other windows (requires ext-windows)
  - visual labels+mode for resizing current window (display hjkl and have an input that when pressing key does the resize operation. maybe like in chrome devtools, using modifiers speeds up the resize increment amount?)
  - visual way to move a window around. display hjkl + input mode. pressing movement command moves window in the direction specified
  - better way to zoom a window, and visually identify that it has been zooooomed
  - swap contents (and size?) of current window with another window (maybe this might be better  alternative than move window (move window could be tricky with complex split trees))
    - like jump labels for moving to window (show window border around current active window)
    - press label and the contents of current and targeted window are swapped around. perhaps resized accordingly?

=============

- we already have the idea of creating custom inventory overlays menus (show a list of keybinds + descriptions - press one and it activates it)
  - it would be neat to have it configurable to either accept ONE keybind or
  - accept N-amount of keybinds until hit esc (aka custom input mode)
  - imagine a list overlay. can press i, o, ; repeatadely to jump between jumplist or changelist

-- add user-guide built-in to veonim. create display window for it (with keybindings)
- requires markdown preview or we generate md -> html on build process

-- bundle vim-polygot with veonim

-- i want to get import completions for node_modules available in 'node_modules' or package.json

-- if lang ext not installed suggest ext on new file type/bufload 
- how does this work if we do not add it to init.vim?

-- custom vim input modes (and guis with keybind visuals + icons):
- window resize
- move windows

-- normalize-filetypes:
- double check that trigger chars are working correctly
  - autocomplete + signature-help
  - test in start.js - should work identical to current version with autocmd fix

-- autocomplete:
- do not hardcode 'tab' + 's-tab' keys. user config
  - at the same time, i don't want so much setup in init.vim...
  - would be nice if veonim worked "out of the box"
  - maybe could check if tab/s-tab is already bound before binding
  - and completefunc?
  - don't override if it exists
- allow opt-in autocomplete trigger. autocmds? -> enable/disable?
  cmd(`set completefunc=VeonimComplete`)
  cmd(`ino <expr> <tab> CompleteScroll(1)`)
  cmd(`ino <expr> <s-tab> CompleteScroll(0)`)
- the problem is that we currently do not render external popupmenu via GUI
  so if someone does not use completefun=VeonimComplete, they will get ugly


-- look into supporting more 3.6.0 lang serv features:
- for example: workspace/configuration
- goto type definition
- goto implementation
- etc


-- interactive lsp:rename. we know all the locations (via find references) of a
symbol, so when we hit rename, we can ciw, and as we update the changes, we
can propagate updates to the rest of the symbols in the visible buffer. on success
update entire buffer. use atomic to batch so no flickr. only undo if lsp rename fail
- can we make it work like xcode? collapse parts of buffer (folds?) and show as many
  lines containing symbol as possible
  interactive rename <lsp>
- veonim rename does cw on all symbols in viewport. use find references to find
  all positions. modify buffer via api but only visible region. on lsp response
  commit renames to full buffer+other docs. only revert if lsp rename failed
- tested that we can use buffer.setLines WHILE in insert mode and the performance
  seems fine. a tad bit laggy, but not a big deal since this feature is only
  seldom used. does not flicker and the updates from .setLines() seems fast enough.
  tested with replacing 2 lines.

  test code (call from 'keydown' event with a setTimeout/setImmediate to not
  hold up rendering):

  --- CODE ---
  const dankMemes = async () => {
    const buf = current.buffer
    const line1 = await buf.getLine(1)
    const line3 = await buf.getLine(3)
    const newLine1 = line1.slice(0, 4) + letters[ix] + line1.slice(4)
    const newLine3 = line3.slice(0, 4) + letters[ix] + line3.slice(4)
    buf.replace(1, newLine1)
    buf.replace(3, newLine3)
    ix = ix + 1 > letters.length - 1 ? 0 : ix + 1
  }
  --- CODE ---
- we should be able to implement this once we have EXTENDED MARKS feature merged

-- constrain overlay menus to a particular window (current window)
- i think we should defer this until we get EXT_WINDOWS - otherwise will need
  to reimplement again
- (if it makes sense to be local - some might be global - like user menus or project switcher)
  - i.e. show symbol/file menu on top of the current buffer window, instead of
  the center of the program, since selecting a symbol or file will make
  changes in the current window, not globally
- right now the overlay menu is hosted in the #plugins div.
  we can get a reference to the current window element and add it in/next to
  the "shadowbuffer" div container. this means that the container will keep
  changing parent div containers. but that is okay, because these window local
  overlay menus will always live inside a specific window, and not be global
- what if the overlay menu does not fit in the window...?

-- tweak the colors.important to bee lesss saturated. can we derive from colorscheme?

-- grep: i don't like the large/small icon unaligned padding/margins in query/filter inputs

-- HOW DOES XTERM HANDLE OVERLAPPING WIDE CHARACTERS?
  - maybe we just use fillText maxWidth property?
  - otherwise we need to cliprect mask. it's the only way with fixed width
    rendering. OS gets around this because it don't do fixed width
    - or somehow dynamic determine if previous char renderd out o bounds, then redraw clipped?

-- visual test results. at least somehow to show total number of fail/pass, last run,
and jumplist for error files. would be nice to have desc and errors as well. maybe
json output? maybe a common format( tap? is it machine readable, containsa ll info? )

-- in the watch-terminal job reader thingy, i wonder if we can detect when a new output
starts by reading for term codes for "clear screen". tsc --watch, mocha --watch,
jest --watch all seem to clear the screen on new runs. any custom scripts i write
could be made to also send the clear screen code. if that's the case, then this
might make it fairly easy to pickup tests/incremental compiler output and know
where a previous run ends and a new one begins.

-- jump to previous/next edit location g; make it repeatable with key-hold transforms pls kthx

-- files not refresh after delete file (the fuzzy file find)
- what about renames?

-- VIRTUAL LISTS PLEASE
  - how to specify dynamic size of list (to fit in the current window?)
  - just make it a slice of the total list
  - can we make a scrollbar to know the ability to scroll

-- neovim buffer notification. now available in 0.3

-- canvasWindow clearReact math.ceil instead of floor. render artifacts on left and right
edges. use ── ──── to test
  - should use clip/rect to draw thingies? perf impact?

-- grep:
  - i'm not sure that we load all the results (in some cases - try searching
      for a popular keyword like 'await'). i think there is some logic to load
  more results from cache once we scroll down... maybe that is not activated
  if the div container height is too high?

-- empty state icon for empty lists [results] - buffer search, etc.

-- shutdown+cleanup langservs on project switch/close

-- change default background/statusline/windows colors to match brunswick default bg

-- NEW HARDER FASTER STRONGER ICON

-- visual-selection high nvim cpu usage... umm... what's going on here

-- code-action/quickfix: does it work correctly?
test case:
  - create multiline js obj `const one = { a\n b\n c\n }`
  - do not use anywhere in file
  - should recv quickfix to remove declaration
  - removes only `const one = {\n` (first line of obj)
  - expected to remove entire object?
    - what does langserv return for workspaceedit?


-- ok i guess i misunderstood how keys work... or there is a bug?
when using keys in hyperapp lists, and clearing parts of the list,
not all removed items are actually removed from the dom. so we end
up with a mix of new and old items in the DOM. lolwut?


-- embed-explorer:
<tab> key is doing something weird. check on it
  - e.preventDefault?
add action to open file in LAST/ALTERNATE buffer, NOT the current one!
don't auto select (active: ix === $.ix) an item in the list unless we have focus
redo home, next, prev keybinds for explorer to not use ctrl + hjkl
figure out better name for embed custom render buffers
generalize embed buffers to support any components
figure out how to swap between different embed components (get buffer name?)
can we support multiple embed components, one per each buffer instance? or shared?
nameplate title changes on window change

-- check on the background of embed explorer, not sure it's the exact same bg color as vim.bg
- using digital color meter.app it is confirmed that the colors are slightly
  off. i checked the logic for setting background is being set correct. in
  fact, when i took the exact bg color specified in the colorscheme.vim and
  applied it directly to the element background color, the subtle color
  difference still persisted. i wonder if the color convert for canvas is doing
  something slightly off. or perhaps html divs have some sort of color profile
  applied but canvas do not...
- test it with hardcoded color values in both html and canvas

-- rpc errors send to notifications? (try calling some broken execute() vimscript from usermenu)

-- upgrade ripgrep


-- mapping for send buffer text (line | selection | word) to nearby terminal window


-- supercharge the vim command line menu. provide menu completions automatically. fuzzy find results.
can we provide a snippet of documentation for the selected menu item? for vim items this can be
the first line from :h. For Veonim we can load from custom place.
- using the same system to make a :Veonim only menu - bind to ctrl_shift_p?
- add code to neovim to automagically send wildmenu options without having to hit wildchar (tab)
- then can fuzzy find vim menus hell yeaaaa
- and show small snippet of :help information

-- create a visual configurator for key remapings + key event viewer. it's hard to figure out otherwise

-- if language extension is not installed, provide a install suggestion like vscode
  on buffer load


-- readme screen showcase automation
  create demo script to start electron at a certain size
  open various features
  use electron/spectron screenshot feature
  save to docs

- showcase/demo fuzzy buffer find in docs
- showcase/demo quickfix


-- mouse support + locked insert mode = pairing support for normie pleb filthy casual philistine swine

-- should there be a 'deactivated/unfocused' style of cursor? i.e. when jumping between Problems
or references, instead of (right now) only showing cursorline, also show the actual cursor block
but perhaps faded out, in such a way to indicate that there is no focus in the vim window...?
  - or like Terminal.app (prob other terms too) show a outline around the block cursor
    - only works for block cursor. we need to support everything


-- make a different cursor for shadow buffers to signify normal mode?


-- super cool start page with mru projects and shit
- better start screen (as shadow buffer) so it looks like you just walked into the sistine chapel and someone handed you a delicious ice cream sandwich with frosted sprinkles on top of the mona lisa

-- image preview (once we get ext windows)

-- move messages to bottom | top right corners. pimp them out to loook dope & lit AF
  - need better support for macro recording
  - yes/no popup dialog with shift_ctrl_y/n styled like messages/notifications to the bottom right


-- better visual macros UI
edit already recorded macros in a floating window
i want the ability to be able to record multiple macros and name them. i want some sort of visual
selector gui so i can retrieve and rerun macros without having to remember what macro register
i saved, and what the usage for a particular macro is supposed to be. this can work similar
to the marks popup idea below

macro recorder real-time history with edit window easily accessible after recording finished to edit
- when starting a macro a small floating window shows up. the window updates in realtime
to reveal the characters typed. when editing finished, a key shortcut will change focus
to the floating window to be able to edit the macro.
- where record keys from? veonim key events? what if neovim remaps?


-- FLOATING WINDOW --
use floating window for terminal scratch buffer. say i want to type a super fancy and long
git commit msg, open scratch buffer, do the edits and whatnot, then "save" buffer to terminal
prompt (this is like c-x, c-e, but it is sized only to fit the content of the prompt)


i want a go to previous buffer in the current window command. PLS
- i thought vim could do this... but the alt buffer or :b# does not
work as expected. maybe need to write a plugin to track bufEnter and
add buffer entries to a stack (per window ofc)

-- mru file jump list
the use case is that i may be jumping thru files either via...
  - goto definition
  - find references

...and i want to go back to the original starting point. the trick is that the
jump list may have other intermediary jumps, so that's not good enough, as i
may have to hit multiple times c-o to go back to origin point.

marks are also not good because i may forget to set them, and sometimes i may
decide to go back to a different origin point (or not all the way up the jump
list chain)

there is go to previous buffer (:b# i think) - but in my testing it does not
seem to function the way i thought it would. plus, if i do indeed side track as
a tangent to another buffer, then this previous buffer process will be
incorrect


-- auto close stale terminal buffers? i.e. if there is no running process in
bash, then if i navigate to a non-term buffer, auto-close the terminal session?
(start new ones instead of switching back). this might solve the problem of
having to remember exactly which terminal might be available for use? right now
terminals are difficult to discern as they just have random numbers, but in the
future if we can name running process in term, thennnnnnnn


-- multi-monitor support? with shada and edge detection (when c-w l on right most
window, go to next monitor)
  - problem is how do we share veonim state between windows.
  - REAL PROBLEM is how to share low-latency functions between windows (render/input/etc)
  - well we can connect via TCP right... i wonder if we can uiAttach from extra clients
  - the problem would be how to maintain state between different processes. things like
    custom input modes...


-- add some sort of error checking/timeout for using lang serv actions, but if the
lang is not loaded yet or requests are taking too long? i.e. calling typescript
find-symbols in a large project (like veonim) after starting up veonim
- or even if the langserv doesn't exist. show some info?
- in vscode if you run a lang action that goes on for too long, it shows
  a progress indicator right under the window tabs. the only thing i don't
  like about it is that you can't cancel/expire lang actions

-----------------------

auto add to quick fix list (to allow :cdo commands):
  references
  problems
  grep 

--neovim PRs--

extended marks:
- https://github.com/neovim/neovim/pull/5031

-
look into how we can use v8 snapshots for startup speed
https://github.com/atom/electron-link
https://www.npmjs.com/package/electron-mksnapshot
https://github.com/atom/atom/blob/f48069c5f848b5ae624b110a1df7800e919eb142/src/native-compile-cache.js
https://flight-manual.atom.io/behind-atom/sections/how-atom-uses-chromium-snapshots/
https://github.com/atom/atom/blob/d9ebd7e125d5f07def1a057a0a8278d4d9d7d23a/script/lib/generate-startup-snapshot.js#L19-L65


## potential ideas
- self-updating? how to handle corporate firewalls?
- full++ veonim build that comes with all langserv extensions, vim-polygot, and other essential vim plugins + barebones vim config
- symbol/tag-tree hierarchical viewer (how does atom-ide do it? or other lang serv clients?)
  - vscode has started implementing this. i think there are corresponding LSP proposals
- user configurable statusline
- snippets (with the next extended marks feature coming soonª to neovim)

## neat ideas that i might want to steal

https://github.com/ShingoFukuyama/helm-swoop
  - i like the idea of putting all search results in a separate buffer, and then performing actions on just the search lines.
    - i like that i can see all search results by themselves
    - like that i can perform INTERACTIVE visually actions on the search results
  - would be cool to have it be fuzzy search (like buffer search) or not
  - with vim can take search results to location/quickfix list and use :cdo - not interactive or visual
  - could use macros somehow...
  - with neovim can use :inccommand and regex or :norm. - can't see all search results by themselves - difficult to revise search selection - not fuzzy. NOT FUZZY


## code quality
use native es6 imports?
https://stackoverflow.com/questions/51113097/electron-es6-module-import

```
const { protocol } = require( 'electron' )
const nfs = require( 'fs' )
const npjoin = require( 'path' ).join
const es6Path = npjoin( __dirname, 'www' )

protocol.registerStandardSchemes( [ 'es6' ] )

app.on( 'ready', () => {
  protocol.registerBufferProtocol( 'es6', ( req, cb ) => {
    nfs.readFile(
      npjoin( es6Path, req.url.replace( 'es6://', '' ) ),
      (e, b) => { cb( { mimeType: 'text/javascript', data: b } ) }
    )
  })
})

<script type="module" src="es6://main.js"></script>
```
