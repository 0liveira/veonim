0.9.0 observations:
- diagnostics stop showing up / error highlights not appearing after some period
- colorizer on action('hint') not coloring anymore after some period of time
- help files missing

would be nice to do :%s@search@replace@g with :inccommand in buffer to get
autocompletes and other vim functionality instead of cmdline...

neovim.ts brings in electron from:
- canvas-container
  - uses electron to register screen change -> resize() handlers
  - i think we could register those handlers outside of canvas-container. galaxy?
  - uses document. can we remove cursor.ts from neovim???
bringing in electron does not work in web workers?

create search box at the top of the current window.
- this will be used for <-- / --> search and viewport-search. maybe more in the future
- can we copystrike pewdiepie. i mean can we blur background + alpha?

viewport-search:
// TODO: if only one search result, jump directly to it
// or maybe if results <= 3? hitting two chars for jump
// label is same as hitting nn (jump to next search)

divination:
- jumpTo line maintains current cursor.col. would be nice to jump to first
  word char in the line (equiv of ^). or maybe the equiv of 0
- line jump: anchor labels to first char in the line? how to?
- do not create label/jump coordinates for position:
  - line -> current line
  - search hl -> position under cursor +/- 1-2

buffer-search: spaces to further filter query (just like fuzzy file finder?)
- i feel like i might want this in a few different places.
  - can create generic fn to use anywhere?

create realtime/live-interactive :g//norm ??cmds?? function. can't build it in vimscript
because of shit UI. would prefer that we can see what's being typed.
i imagine it might work something like:
  - open input cmd (same as cmd-line? but diff icon?)
  - would be best to have two inputs
    - input 1: filter (if any - can be optional?)
      - if not specified will use current/last search pattern
      - need to somehow specify that want to apply to every line
        - then run :norm ??cmds?? (or with visual selection marks)
    - input 2: normal mode commands. assumes they will be remapped
      - on string+ :g//norm ??cmds??
      - on string- :undo
      - i wonder if we can/should highlight changes in diff color?
      - need someway to escape special chars (enter, space, ctrl-key, etc.)

figure out why jest is the worst thing ever since sliced bread

replace request with native https. just need to figure out how to pipe in my fetch code

grep: i don't like the large/small icon unaligned padding/margins in query/filter inputs

constrain overlay menus to a particular window (current window)
- (if it makes sense to be local - some might be global - like user menus or project switcher)
  - i.e. show symbol/file menu on top of the current buffer window, instead of
  the center of the program, since selecting a symbol or file will make
  changes in the current window, not globally
- right now the overlay menu is hosted in the #plugins div.
  we can get a reference to the current window element and add it in/next to
  the "shadowbuffer" div container. this means that the container will keep
  changing parent div containers. but that is okay, because these window local
  overlay menus will always live inside a specific window, and not be global

- HOW DOES XTERM HANDLE OVERLAPPING WIDE CHARACTERS?
  - maybe we just use fillText maxWidth property?
  - otherwise we need to cliprect mask. it's the only way with fixed width
    rendering. OS gets around this because it don't do fixed width

easymotion show bigger letters + show WHILE searching ooooooo

visual test results. at least somehow to show total number of fail/pass, last run,
and jumplist for error files. would be nice to have desc and errors as well. maybe
json output? maybe a common format( tap? is it machine readable, containsa ll info? )

in the watch-terminal job reader thingy, i wonder if we can detect when a new output
starts by reading for term codes for "clear screen". tsc --watch, mocha --watch,
jest --watch all seem to clear the screen on new runs. any custom scripts i write
could be made to also send the clear screen code. if that's the case, then this
might make it fairly easy to pickup tests/incremental compiler output and know
where a previous run ends and a new one begins.

terminal change title to current running process

jump to previous/next edit location g; make it repeatable with key-hold transforms pls kthx

easymotion jump to highlighted word
  - i don't remember what i meant when i wrote this... maybe when i have a
    visual selection, have an easymotion keybinding to jump between them real
    fast instead of n n n n n n n n n. could be useful i suppose. maybe extend
    for problems, symbol highlights, references, etc.

create find overlay at the top or bottom of current window (like xcode/vscode/atom/sublime/etc). used for builtin vim / or ? and can be used by custom components (viewport fuzzy search)
  - maybe the design can integrate somehow with the buffer fuzzy search list
  - background blur/transparent
  - i think this has some usefulness as right now the search is in the middle
    of the screen covering up a lot of code viewport

files not refresh after delete file (the fuzzy file find)

buffer-search: virtual-list
create a simple hyperapp virtualized list component that simply renders dom nodes
given a slice of the list. you want the top of the list, slice(0, 10)
you want the end, slice(list.length - 10), etc. no mouse support for now.
keep it simple and easy. make it composable (vs higher order?/wrapping?)

neovim buffer notification. now available in 0.3

canvasWindow clearReact math.ceil instead of floor. render artifacts on left and right
edges. use ── ──── to test
  - should use clip/rect to draw thingies? perf impact?

hide overlays (problem info, hover) on bufleave
  - happens when switch tabs

grep:
  - if we start a query that results are found, but then expand the query to
  something that does not return results, we are not clearing the ui
  - i'm not sure that we load all the results (in some cases - try searching
      for a popular keyword like 'await'). i think there is some logic to load
  more results from cache once we scroll down... maybe that is not activated
  if the div container height is too high?


FIX INTERFACES TO NOT HAVE COMMAS LOL IM STUPID
  - don't do it manually

investigate usage of css filter `backdrop-filter` (blur)
https://developer.mozilla.org/en-US/docs/Web/CSS/backdrop-filter
  - requires "Experimental Web Platform Features" flag enabled
  - investigate how to do this in electron

empty state icon for empty lists [results] - buffer search, etc.

depmgr as separate process (not even worker thread) - because of security and isolation?
- needs access to configReader on file watch
- can use proletariat for maximum communism

shutdown+cleanup langservs on project switch/close

change default background/statusline/windows colors to match brunswick default bg

NEW HARDER FASTER STRONGER ICON

investigate usage of 'requestIdleCallback'
https://developer.mozilla.org/en-US/docs/Web/API/Window/requestIdleCallback

see if we can collapse/merge/condense state.ts with neovim.ts:current + getCurrent

visual-selection high nvim cpu usage... umm... what's going on here

code-action/quickfix: does it work correctly?
test case:
  - create multiline js obj `const one = { a\n b\n c\n }`
  - do not use anywhere in file
  - should recv quickfix to remove declaration
  - removes only `const one = {\n` (first line of obj)
  - expected to remove entire object?
    - what does langserv return for workspaceedit?

separate out internal object data from langserv params data?
- right now in adapter we send both vim state object and params in the same
  parameter, same object. i think it might be cleaner to send them separately,
  so that we do not send internal data to the lang serv. this may have a
  neglible benefit on network (de)serializing (and xmit time?)
- i almost feel that there is not much of a good reason to pass in the entire
  neovim state to every single langserv request ever. why can't adapter simply
  access the neovim state and pick out the nvim state fields it needs to know?

should we add a timeout for key-hold transforms? in my mapping of caps-lock ->
esc/cmd it happens that sometimes i press cmd thinking i want to use it as cmd
(e.g. gonna press cmd+h) but then change my mind and never press the second key
while holding caps-lock (cmd).  in this case, the event will fire as esc, but
probably did not intend since it was such a long hold.  anyways this can be
opt-in behavior
  - should normalize this behavior to also apply to html input key event handlers

simliar to the key timeouts, maybe we can make key triggers after a certain amount
of key-down holding. e.g. press/release m immediatly and it takes you to a mark.
press and hold m and a mark menu shows up

spammy cmd-update lolwut?

ok i guess i misunderstood how keys work... or there is a bug?
when using keys in hyperapp lists, and clearing parts of the list,
not all removed items are actually removed from the dom. so we end
up with a mix of new and old items in the DOM. lolwut?

should font-sizer be part of build process?

STOP REQUIRING SO MUCH SHIT ON APP START LOL
  - lazy load more shit
  - web worker more shit (ai)

- SHADOW BUFFERS -
the problem with shadow buffers is that our current neovim window render strategy
just picks a random html div and does its thing. we need to be semantic and render
windwos to specific divs. we need to associate a specific div with a specific vim
window and maintain that relationship so that shadow buffers are tied to the correct
html element.

if we assign a div to each window, how will this work with tabpage switch? right now it's
super clean and performant as the div elements are reused/not modified
  - what if tab switch to the exact same windows, but just swapped around in layout order
    - file1 + file2 -> file2 + file1

shadow buffers:
cursor.ts does not recognize current window as shadow-buffer-type anymore... what changed?
re-ordering windows fail - try creating new split when a shadow buffer already open

what to do when shadow buffer component goes back to normal mode?? need to display
some sort of visual feedback. don't move cursor around etc. maybe also disable notifications

// TODO: in addition to close/rename, we also need to detect when a window gets reassigned
// and unload/reload shadow buffer. window container elements do not follow vim windows

are we still resizing inappropriately?
try to see what happens with NERDTree when open a layout like this
left nerd, middle two horizontal splits, right open ;ve
| | | |
|-|-|-|
| | | |
does it get resized equally?

embed-explorer:
<tab> key is doing something weird. check on it
  - e.preventDefault?
add action to open file in LAST/ALTERNATE buffer, NOT the current one!
don't auto select (active: ix === $.ix) an item in the list unless we have focus
redo home, next, prev keybinds for explorer to not use ctrl + hjkl
figure out better name for embed custom render buffers
generalize embed buffers to support any components
figure out how to swap between different embed components (get buffer name?)
can we support multiple embed components, one per each buffer instance? or shared?
nameplate title changes on window change

--

should probably stop auto adjusting windows with (wincmd =)
  this is immediatly obvious now with non-equal width windows (embed explorer)
  can we be smarter about this? maybe figure out widths before resize grid?
  only apply wincmd = in certain conditions?

check on the background of embed explorer, not sure it's the exact same bg color as vim.bg
- using digital color meter.app it is confirmed that the colors are slightly
  off. i checked the logic for setting background is being set correct. in
  fact, when i took the exact bg color specified in the colorscheme.vim and
  applied it directly to the element background color, the subtle color
  difference still persisted. i wonder if the color convert for canvas is doing
  something slightly off. or perhaps html divs have some sort of color profile
  applied but canvas do not...

rpc errors send to notifications? (try calling some broken execute() vimscript from usermenu)

upgrade ripgrep

--ideas--

readme screen showcase automation
  create demo script to start electron at a certain size
  open various features
  use electron/spectron screenshot feature
  save to docs

- showcase/demo fuzzy buffer find in docs
- showcase/demo quickfix

mouse support + locked insert mode = pairing support for normie pleb filthy casual philistine swine

i want a go to previous buffer in the current window command. PLS
- i thought vim could do this... but the alt buffer or :b# does not
  work as expected. maybe need to write a plugin to track bufEnter and
  add buffer entries to a stack (per window ofc)

should there be a 'deactivated/unfocused' style of cursor? i.e. when jumping between Problems
or references, instead of (right now) only showing cursorline, also show the actual cursor block
but perhaps faded out, in such a way to indicate that there is no focus in the vim window...?
  - or like Terminal.app (prob other terms too) show a outline around the block cursor
    - only works for block cursor. we need to support everything

make a different cursor for shadow buffers to signify normal mode?

super cool start page with mru projects and shit

move messages to bottom | top right corners. pimp them out to loook dope & lit AF
  - need better support for macro recording

image preview buffers

-- FLOATING WINDOW --
i want the ability to be able to record multiple macros and name them. i want some sort of visual
selector gui so i can retrieve and rerun macros without having to remember what macro register
i saved, and what the usage for a particular macro is supposed to be. this can work similar
to the marks popup idea below

use floating window for terminal scratch buffer. say i want to type a super fancy and long
git commit msg, open scratch buffer, do the edits and whatnot, then "save" buffer to terminal
prompt

press and hold mark ' keybind to bring up menu of current global marks
menu lists something like
a - support.ts
s - utils.ts
d - main.ts

pressing one of the keys takes you to that file
releasing mark keybind closes menu without any navigation
(think kinda like opie addon, but hold activate)

- mru file jump list
the use case is that i may be jumping thru files either via...
  - goto definition
  - find references

...and i want to go back to the original starting point. the trick is that the
jump list may have other intermediary jumps, so that's not good enough, as i
may have to hit multiple times c-o to go back to origin point.

marks are also not good because i may forget to set them, and sometimes i may
decide to go back to a different origin point (or not all the way up the jump
list chain)

there is go to previous buffer (:b# i think) - but in my testing it does not
seem to function the way i thought it would. plus, if i do indeed side track as
a tangent to another buffer, then this previous buffer process will be
incorrect


-- auto close stale terminal buffers? i.e. if there is no running process in
bash, then if i navigate to a non-term buffer, auto-close the terminal session?
(start new ones instead of switching back). this might solve the problem of
having to remember exactly which terminal might be available for use? right now
terminals are difficult to discern as they just have random numbers, but in the
future if we can name running process in term, thennnnnnnn

multi-monitor support? with shada and edge detection (when c-w l on right most
window, go to next monitor)
  - problem is how do we share veonim state between windows.
  - REAL PROBLEM is how to share low-latency functions between windows (render/input/etc)


add some sort of error checking/timeout for using lang serv actions, but if the
lang is not loaded yet or requests are taking too long? i.e. calling typescript
find-symbols in a large project (like veonim) after starting up veonim
- or even if the langserv doesn't exist. show some info?


-----------------------

auto add to quick fix list (to allow :cdo commands):
  references
  problems
  grep 

--neovim PRs--

extended marks:
- https://github.com/neovim/neovim/pull/5031

-
look into how we can use v8 snapshots for startup speed
https://github.com/atom/electron-link
https://www.npmjs.com/package/electron-mksnapshot
https://github.com/atom/atom/blob/f48069c5f848b5ae624b110a1df7800e919eb142/src/native-compile-cache.js
https://flight-manual.atom.io/behind-atom/sections/how-atom-uses-chromium-snapshots/
https://github.com/atom/atom/blob/d9ebd7e125d5f07def1a057a0a8278d4d9d7d23a/script/lib/generate-startup-snapshot.js#L19-L65


## near future
- add language server protocol 3.6.0 support: 
  - goto implementation/type def/etc
    - add more SymbolKind(s) and more CompletionItemKind(s). already enabled in capabilities, just need to enable the usage

    ## potential ideas
    - self-updating? how to handle corporate firewalls?
    - full++ veonim build that comes with all langserv extensions, vim-polygot, and other essential vim plugins + barebones vim config
    - image preview
    - markdown preview
    - better start screen (as shadow buffer) so it looks like you just walked into the sistine chapel and someone handed you a delicious ice cream sandwich with frosted sprinkles on top of the mona lisa
    - browser??????? safety????????????????? (maybe localhost only)
    - add code to neovim to automagically send wildmenu options without having to hit wildchar (tab)
      - then can fuzzy find vim menus hell yeaaaa
    - symbol/tag-tree hierarchical viewer (how does atom-ide do it? or other lang serv clients?)
      - vscode has started implementing this. i think there are corresponding LSP proposals
    - custom renderer (like custom ui for quickfix, etc.)
    - user configurable statusline
    - delay cmdline show if hide really quick to prevent flash - see #203 (https://github.com/veonim/veonim/issues/230)
    - helm discoverability menu or c-s-p fuzzy menu (i think i prefer the fuzzy, better for finding seldom used functions)
    - snippets (with the next extended marks feature coming soonª to neovim)

## grid dynamic resize (prolly not needed with fancy nvim window mgmt)

TODO: what if we could calculate availableColumns BEFORE hand?  it
should be deterministic based on the current grid size and
canvas-window paddings (how does this help?)

TODO: what if we apply a grid resize operation BEFORE the split
window event gets sent and processed. how could we intercept and
freeze split cmds?  api.getUserKeymap? listen for split key
events? WinNew autocmd?  if resize before, then there won't be a
need to wincmd = there will still be some shift, but maybe not
so much...

TODO: what if resize grid so it will always fit
n-windows + 1 that is, if there is only 1 window, the
grid will be resized to accomodate 2.  when 2 happen,
they will be resized for 3.
