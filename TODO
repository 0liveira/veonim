investigate rendering glitches (not only in sessions) like cursorline getting stuck last block on some lines

move all rendering logic to separate file?

setup staging build (figure out how to remove process.env.DEV_MODE from production build. codemod?)
  - use custom node launcher script to inject env var = devmode, remove global env- not work electron
setup watch/reload for faster ui iteration (tsc watch, etc.)
setup hyperapp ui framework
  - vla for hyperapp
  - each component in separate div? or all shared? all shared might mean too much rerender entire root tree

create rename current window
create fuzzy list switcher
create input for creating window
create buffer switcher
create file switcher
create directory/file browser (two modes? one for cwd and another for files)

change cwd in vim instance (set to $HOME by default?)
  - two different shortcuts. one default: create new vim instance at $HOME (with terms only?)
  - another the ctrl+t+p (like in tmux) list projects and open vim in provided working dir (term/vim split?)

reconsider how configs will be loaded from vim (because we have multiple vims now + howto hot reload)
  // we only need this once... do we want to support multi configs per different instances?
  // i think not. this means that we need at least one instance BOUND to get vars
  // every other time we will just use the vars from the first instance.
  // would it be simpler just to FS parse vimrc for these options? assuming no dynamic shenanigans...
  // could use a separate process/thread to get configs in parallel while ui and nvim instances are started
  // what about configs changing. chokidar on vimrc?
  // what about different vimrc locations? always assume ~/.config/neovim/init.vim?
  // what about spawning a separate process and dummy spawning nvim instance just to read vars? or read vimrc location? what's the advantage then of just calling it this way?

  // loading configs via api takes ~75ms. WAY TOO LONG
  // i think FS read might be cleanest (esp for reload) (think about multi vim sessions too)
    - should benchmark speed. (could be slower on non-ssd, but can be parallel)

concurrency methods:
child_process -> alone, good for adhoc (list files, ripgrep, etc)
web worker -> will need to hook into socket server from neovim. don't have shared worker

chokidar file reload vim buffers
  - how handle multi sessions

how to "zoom" vim pane? create new tab with selected buffer only? unzoom destroy tab and go back to prev tab?

embed binaries in release build

-- maybe
KARABINER: FIX SHIFT;;;;;;;
can we replace kr-el for semi maps? (since we have key down/up events)
  - could, but using kr-el binds elsewhere (system ctrls, could remap)
  - remap left cmd to something else (system ctrls...?)
  - caps lock -> left cmd
    - veonim -> cmd/esc
    - other apps -> left cmd (caps lock) + other modifier == esc? or cmd[?
fix tiny rendering glitches when typing? are we rounding somwhere or losing precision in calculations?
perf improvements?

consider using canvas cursor to do better blend with vim canvas (what about cursor for inputs?)
https://developer.mozilla.org/en-US/docs/Web/API/CanvasRenderingContext2D/globalCompositeOperation
https://github.com/Phrogz/context-blender
actually - could get char from canvas at x/y (under cursor) and then render it in the cursor el but inverted (if block cursor)

git view: overlay on left (like vscode) - select files and open in new vim tab git diff split view via fugitive

-- tried, failed, gave up
support cursor colors - almost there: issue in getting color for id (synIDattr does not return val even in nvim)
