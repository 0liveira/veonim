0.9.0 observations:
- diagnostics stop showing up / error highlights not appearing after some period
  - not observed on my main machine, only on secondary... same build version?
- colorizer on action('hint') not coloring anymore after some period of time
  - again, no issue on main machine...
  - main is alpha4
- actually i notice that problem underlines/highlights stop working after some time on
  my main machine...
- help files missing
- Veonim buffers a little laggy and flickers windows???

change-dir/vim-create-dir default dir to :pwd if not specified. should we default
to g:vn_project_root if defined? it appears we use g:vn_project root to simplify
path displayed in "project" statusline section

document search-fn space

bundle vim-polygot with veonim
maybe create a veonim vimscript plugin to speed up load timem

package.json node_modules import completions

debug

if lang ext not installed suggest ext on new file type/bufload 

custom vim input modes:
- window resize
- move windows

normalize-filetypes:
- double check that trigger chars are working correctly
  - autocomplete + signature-help
  - test in start.js - should work identical to current version with autocmd fix

autocomplete:
- do not hardcode 'tab' + 's-tab' keys. user config
- allow opt-in autocomplete trigger. autocmds? -> enable/disable?
- need to change neovim.ts -> onCreate()
  cmd(`set completefunc=VeonimComplete`)
  cmd(`ino <expr> <tab> CompleteScroll(1)`)
  cmd(`ino <expr> <s-tab> CompleteScroll(0)`)
- the problem is that we currently do not render external popupmenu via GUI
  so if someone does not use completefun=VeonimComplete, they will get ugly

vim-search:
- dispatch callback events to vim when the vim-search window has closed
- also pass in the type of search that happened: (forward|backward)
- this can be used with some vimscript to call divination-search
  after a vim search completes
- sometimes triggering on cmdsdsdsdsd
- vim search hide action throwing error window not found. maybe redux, but
  does it do the same in dist mode?

key-transform:
- support different modes

look into supporting more 3.6.0 lang serv features:
- for example: workspace/configuration
- goto type definition
- goto implementation
- etc
- support extra symbol/completion icons (commented out in components)

DEV_MDOE -> SPECTRON
- the following crashes the thing:
  - opening devtools :: win.webContents.openDevTools()
  - installing devtools extensions :: load(REDUX_DEVTOOLS.id)
- opening devtools from spectron crashes as well (different error though)
   - it does open the devtools, but protocol crashes somewhere
- i think any kind of messing around with devtools is bad because
  devtools is probably the domain of SPECTRON (remote debugging and what not)
  - try to do all devtools commands thru SPECTRON api

use user menu to create a git branch switcher. add it docs

annotate marks in buffer. experiment with drawing on top of render buffer output?
- can get mark info via :marks?

interactive lsp:rename. we know all the locations (via find references) of a
symbol, so when we hit rename, we can ciw, and as we update the changes, we
can propagate updates to the rest of the symbols in the visible buffer. on success
update entire buffer. use atomic to batch so no flickr. only undo if lsp rename fail
- can we make it work like xcode? collapse parts of buffer (folds?) and show as many
  lines containing symbol as possible
  interactive rename <lsp>
- veonim rename does cw on all symbols in viewport. use find references to find
  all positions. modify buffer via api but only visible region. on lsp response
  commit renames to full buffer+other docs. only revert if lsp rename failed
- tested that we can use buffer.setLines WHILE in insert mode and the performance
  seems fine. a tad bit laggy, but not a big deal since this feature is only
  seldom used. does not flicker and the updates from .setLines() seems fast enough.
  tested with replacing 2 lines.

  test code (call from 'keydown' event with a setTimeout/setImmediate to not
  hold up rendering):

  --- CODE ---
  const dankMemes = async () => {
    const buf = current.buffer
    const line1 = await buf.getLine(1)
    const line3 = await buf.getLine(3)
    const newLine1 = line1.slice(0, 4) + letters[ix] + line1.slice(4)
    const newLine3 = line3.slice(0, 4) + letters[ix] + line3.slice(4)
    buf.replace(1, newLine1)
    buf.replace(3, newLine3)
    ix = ix + 1 > letters.length - 1 ? 0 : ix + 1
  }
  --- CODE ---
- we should be able to implement this once we have EXTENDED MARKS feature merged

constrain overlay menus to a particular window (current window)
- i think we should defer this until we get EXT_WINDOWS - otherwise will need
  to reimplement again
- (if it makes sense to be local - some might be global - like user menus or project switcher)
  - i.e. show symbol/file menu on top of the current buffer window, instead of
  the center of the program, since selecting a symbol or file will make
  changes in the current window, not globally
- right now the overlay menu is hosted in the #plugins div.
  we can get a reference to the current window element and add it in/next to
  the "shadowbuffer" div container. this means that the container will keep
  changing parent div containers. but that is okay, because these window local
  overlay menus will always live inside a specific window, and not be global
- what if the overlay menu does not fit in the window...?

tweak the colors.important to bee lesss saturated. can we derive from colorscheme?

viewport-search, make sure search only happens in visible viewport!
- open $vimrc
- 2 c-d (page-down scroll)
- move cursor line like 30% down in the window
- search for 'job'
- as it happens, the buffer is scrolled away from the current line range. why?
  - is it because 'job' is not found in the viewport?

divination:
- whatever method we use for jumping does not add jumps to jumplist
- line jump: anchor labels to first char in the line? how to?
  - call getVisibleLines, find the first non-space char, count how many columns in the first char is in
    return [row, col][] list map
- do not create label/jump coordinates for position:
  - line -> current line
  - search hl -> position under cursor +/- 1-2
  - do not apply for viewport-search. only if invoked directly
- handle error if type bad label that does not exist. do what?
  - escape?
  - drop keys?
- create binding for divination-search and set it up to work without previous prompts.
  - aka, do viewport search to jump to search highlight
  - then have a binding to trigger the jump labels again. can we do something with
    key hold-down??
    - i.e. hold down <s-space> and press two letters: 'AD' to jump to search?

buffer-search: spaces to further filter query (just like fuzzy file finder?)
- if only one result in list and i hit enter, jump to the first result
  - actually should this be behavior even if there are more than one result? if hit enter, select first and jump to it (even if not selected_
- i feel like i might want this in a few different places.
  - can create generic fn to use anywhere?
- collect & show line numbers?

figure out why jest is the worst thing ever since sliced bread

replace request with native https. just need to figure out how to pipe in my fetch code
build custom colorpicker in hyperapp

grep: i don't like the large/small icon unaligned padding/margins in query/filter inputs

- HOW DOES XTERM HANDLE OVERLAPPING WIDE CHARACTERS?
  - maybe we just use fillText maxWidth property?
  - otherwise we need to cliprect mask. it's the only way with fixed width
    rendering. OS gets around this because it don't do fixed width
    - or somehow dynamic determine if previous char renderd out o bounds, then redraw clipped?

easymotion show bigger letters + show WHILE searching ooooooo
- how label triggered?
- is it distracting that labels covering highlights?

visual test results. at least somehow to show total number of fail/pass, last run,
and jumplist for error files. would be nice to have desc and errors as well. maybe
json output? maybe a common format( tap? is it machine readable, containsa ll info? )

in the watch-terminal job reader thingy, i wonder if we can detect when a new output
starts by reading for term codes for "clear screen". tsc --watch, mocha --watch,
jest --watch all seem to clear the screen on new runs. any custom scripts i write
could be made to also send the clear screen code. if that's the case, then this
might make it fairly easy to pickup tests/incremental compiler output and know
where a previous run ends and a new one begins.

terminal change title to current running process

jump to previous/next edit location g; make it repeatable with key-hold transforms pls kthx

easymotion jump to highlighted word
  - i don't remember what i meant when i wrote this... maybe when i have a
    visual selection, have an easymotion keybinding to jump between them real
    fast instead of n n n n n n n n n. could be useful i suppose. maybe extend
    for problems, symbol highlights, references, etc.

files not refresh after delete file (the fuzzy file find)

buffer-search: virtual-list
create a simple hyperapp virtualized list component that simply renders dom nodes
given a slice of the list. you want the top of the list, slice(0, 10)
you want the end, slice(list.length - 10), etc. no mouse support for now.
keep it simple and easy. make it composable (vs higher order?/wrapping?)

neovim buffer notification. now available in 0.3

canvasWindow clearReact math.ceil instead of floor. render artifacts on left and right
edges. use ── ──── to test
  - should use clip/rect to draw thingies? perf impact?

hide overlays (problem info, hover) on bufleave
  - happens when switch tabs

grep:
  - if we start a query that results are found, but then expand the query to
  something that does not return results, we are not clearing the ui
  - i'm not sure that we load all the results (in some cases - try searching
      for a popular keyword like 'await'). i think there is some logic to load
  more results from cache once we scroll down... maybe that is not activated
  if the div container height is too high?


FIX INTERFACES TO NOT HAVE COMMAS LOL IM STUPID
  - don't do it manually

empty state icon for empty lists [results] - buffer search, etc.

depmgr as separate process (not even worker thread) - because of security and isolation?
- needs access to configReader on file watch
- can use proletariat for maximum communism

shutdown+cleanup langservs on project switch/close

change default background/statusline/windows colors to match brunswick default bg

NEW HARDER FASTER STRONGER ICON

investigate usage of 'requestIdleCallback'
https://developer.mozilla.org/en-US/docs/Web/API/Window/requestIdleCallback

see if we can collapse/merge/condense state.ts with neovim.ts:current + getCurrent

visual-selection high nvim cpu usage... umm... what's going on here

code-action/quickfix: does it work correctly?
test case:
  - create multiline js obj `const one = { a\n b\n c\n }`
  - do not use anywhere in file
  - should recv quickfix to remove declaration
  - removes only `const one = {\n` (first line of obj)
  - expected to remove entire object?
    - what does langserv return for workspaceedit?

separate out internal object data from langserv params data?
- right now in adapter we send both vim state object and params in the same
  parameter, same object. i think it might be cleaner to send them separately,
  so that we do not send internal data to the lang serv. this may have a
  neglible benefit on network (de)serializing (and xmit time?)
- i almost feel that there is not much of a good reason to pass in the entire
  neovim state to every single langserv request ever. why can't adapter simply
  access the neovim state and pick out the nvim state fields it needs to know?

should we add a timeout for key-hold transforms? in my mapping of caps-lock ->
esc/cmd it happens that sometimes i press cmd thinking i want to use it as cmd
(e.g. gonna press cmd+h) but then change my mind and never press the second key
while holding caps-lock (cmd).  in this case, the event will fire as esc, but
probably did not intend since it was such a long hold.  anyways this can be
opt-in behavior
  - should normalize this behavior to also apply to html input key event handlers

simliar to the key timeouts, maybe we can make key triggers after a certain amount
of key-down holding. e.g. press/release m immediatly and it takes you to a mark.
press and hold m and a mark menu shows up

ok i guess i misunderstood how keys work... or there is a bug?
when using keys in hyperapp lists, and clearing parts of the list,
not all removed items are actually removed from the dom. so we end
up with a mix of new and old items in the DOM. lolwut?

should font-sizer be part of build process?

STOP REQUIRING SO MUCH SHIT ON APP START LOL
  - lazy load more shit
  - web worker more shit (ai)

- SHADOW BUFFERS -
the problem with shadow buffers is that our current neovim window render strategy
just picks a random html div and does its thing. we need to be semantic and render
windwos to specific divs. we need to associate a specific div with a specific vim
window and maintain that relationship so that shadow buffers are tied to the correct
html element.

if we assign a div to each window, how will this work with tabpage switch? right now it's
super clean and performant as the div elements are reused/not modified
  - what if tab switch to the exact same windows, but just swapped around in layout order
    - file1 + file2 -> file2 + file1

shadow buffers:
cursor.ts does not recognize current window as shadow-buffer-type anymore... what changed?
re-ordering windows fail - try creating new split when a shadow buffer already open

what to do when shadow buffer component goes back to normal mode?? need to display
some sort of visual feedback. don't move cursor around etc. maybe also disable notifications

// TODO: in addition to close/rename, we also need to detect when a window gets reassigned
// and unload/reload shadow buffer. window container elements do not follow vim windows

are we still resizing inappropriately?
try to see what happens with NERDTree when open a layout like this
left nerd, middle two horizontal splits, right open ;ve
| | | |
|-|-|-|
| | | |
does it get resized equally?

embed-explorer:
<tab> key is doing something weird. check on it
  - e.preventDefault?
add action to open file in LAST/ALTERNATE buffer, NOT the current one!
don't auto select (active: ix === $.ix) an item in the list unless we have focus
redo home, next, prev keybinds for explorer to not use ctrl + hjkl
figure out better name for embed custom render buffers
generalize embed buffers to support any components
figure out how to swap between different embed components (get buffer name?)
can we support multiple embed components, one per each buffer instance? or shared?
nameplate title changes on window change

--

should probably stop auto adjusting windows with (wincmd =)
  this is immediatly obvious now with non-equal width windows (embed explorer)
  can we be smarter about this? maybe figure out widths before resize grid?
  only apply wincmd = in certain conditions?

check on the background of embed explorer, not sure it's the exact same bg color as vim.bg
- using digital color meter.app it is confirmed that the colors are slightly
  off. i checked the logic for setting background is being set correct. in
  fact, when i took the exact bg color specified in the colorscheme.vim and
  applied it directly to the element background color, the subtle color
  difference still persisted. i wonder if the color convert for canvas is doing
  something slightly off. or perhaps html divs have some sort of color profile
  applied but canvas do not...

rpc errors send to notifications? (try calling some broken execute() vimscript from usermenu)

upgrade ripgrep

--ideas--

update user-guide to present an option for lang shortcuts as overlay user menu instead of bindings

mapping for send buffer text to nearby terminal window

macro recorder real-time history with edit window easily accessible after recording finished to edit
- when starting a macro a small floating window shows up. the window updates in realtime
  to reveal the characters typed. when editing finished, a key shortcut will change focus
  to the floating window to be able to edit the macro.
- where record keys from? veonim key events? what if neovim remaps?

configurable mouse cursor hide enable/disable - enabled by default

create overlay menu window with key shortcuts so users can create spacemacs-like
menus. e.g. (floating windows maybe?)
- press and hold a key to open up menu. next key press while key is being held will trigger action
- press key to bring up menu. next key selects an action from the menu
[ a: buffer search    b: grep search    c: viewport-search ]
[ d: file search                                           ]

add documentation about guifont/size/cursor/colorscheme/roboto/etc

supercharge the vim command line menu. provide menu completions automatically. fuzzy find results.
can we provide a snippet of documentation for the selected menu item? for vim items this can be
the first line from :h. For Veonim we can load from custom place.
- using the same system to make a :Veonim only menu - bind to ctrl_shift_p?

create a visual configurator for key remapings + key event viewer. it's hard to figure out otherwise

if language extension is not installed, provide a install suggestion like vscode
on buffer load

yes/no popup dialog with shift_ctrl_y/n styled like messages/notifications to the bottom right

readme screen showcase automation
  create demo script to start electron at a certain size
  open various features
  use electron/spectron screenshot feature
  save to docs

- showcase/demo fuzzy buffer find in docs
- showcase/demo quickfix

mouse support + locked insert mode = pairing support for normie pleb filthy casual philistine swine

i want a go to previous buffer in the current window command. PLS
- i thought vim could do this... but the alt buffer or :b# does not
  work as expected. maybe need to write a plugin to track bufEnter and
  add buffer entries to a stack (per window ofc)

should there be a 'deactivated/unfocused' style of cursor? i.e. when jumping between Problems
or references, instead of (right now) only showing cursorline, also show the actual cursor block
but perhaps faded out, in such a way to indicate that there is no focus in the vim window...?
  - or like Terminal.app (prob other terms too) show a outline around the block cursor
    - only works for block cursor. we need to support everything

make a different cursor for shadow buffers to signify normal mode?

super cool start page with mru projects and shit

move messages to bottom | top right corners. pimp them out to loook dope & lit AF
  - need better support for macro recording

image preview buffers

-- FLOATING WINDOW --
edit already recorded macros in a floating window
i want the ability to be able to record multiple macros and name them. i want some sort of visual
selector gui so i can retrieve and rerun macros without having to remember what macro register
i saved, and what the usage for a particular macro is supposed to be. this can work similar
to the marks popup idea below

use floating window for terminal scratch buffer. say i want to type a super fancy and long
git commit msg, open scratch buffer, do the edits and whatnot, then "save" buffer to terminal
prompt

press and hold mark ' keybind to bring up menu of current global marks
menu lists something like
a - support.ts
s - utils.ts
d - main.ts

pressing one of the keys takes you to that file
releasing mark keybind closes menu without any navigation
(think kinda like opie addon, but hold activate)

- mru file jump list
the use case is that i may be jumping thru files either via...
  - goto definition
  - find references

...and i want to go back to the original starting point. the trick is that the
jump list may have other intermediary jumps, so that's not good enough, as i
may have to hit multiple times c-o to go back to origin point.

marks are also not good because i may forget to set them, and sometimes i may
decide to go back to a different origin point (or not all the way up the jump
list chain)

there is go to previous buffer (:b# i think) - but in my testing it does not
seem to function the way i thought it would. plus, if i do indeed side track as
a tangent to another buffer, then this previous buffer process will be
incorrect


-- auto close stale terminal buffers? i.e. if there is no running process in
bash, then if i navigate to a non-term buffer, auto-close the terminal session?
(start new ones instead of switching back). this might solve the problem of
having to remember exactly which terminal might be available for use? right now
terminals are difficult to discern as they just have random numbers, but in the
future if we can name running process in term, thennnnnnnn

multi-monitor support? with shada and edge detection (when c-w l on right most
window, go to next monitor)
  - problem is how do we share veonim state between windows.
  - REAL PROBLEM is how to share low-latency functions between windows (render/input/etc)


add some sort of error checking/timeout for using lang serv actions, but if the
lang is not loaded yet or requests are taking too long? i.e. calling typescript
find-symbols in a large project (like veonim) after starting up veonim
- or even if the langserv doesn't exist. show some info?


-----------------------

auto add to quick fix list (to allow :cdo commands):
  references
  problems
  grep 

--neovim PRs--

extended marks:
- https://github.com/neovim/neovim/pull/5031

-
look into how we can use v8 snapshots for startup speed
https://github.com/atom/electron-link
https://www.npmjs.com/package/electron-mksnapshot
https://github.com/atom/atom/blob/f48069c5f848b5ae624b110a1df7800e919eb142/src/native-compile-cache.js
https://flight-manual.atom.io/behind-atom/sections/how-atom-uses-chromium-snapshots/
https://github.com/atom/atom/blob/d9ebd7e125d5f07def1a057a0a8278d4d9d7d23a/script/lib/generate-startup-snapshot.js#L19-L65


## near future
- add language server protocol 3.6.0 support: 
  - goto implementation/type def/etc
    - add more SymbolKind(s) and more CompletionItemKind(s). already enabled in capabilities, just need to enable the usage

    ## potential ideas
    - self-updating? how to handle corporate firewalls?
    - full++ veonim build that comes with all langserv extensions, vim-polygot, and other essential vim plugins + barebones vim config
    - image preview
    - markdown preview
    - better start screen (as shadow buffer) so it looks like you just walked into the sistine chapel and someone handed you a delicious ice cream sandwich with frosted sprinkles on top of the mona lisa
    - browser??????? safety????????????????? (maybe localhost only)
    - add code to neovim to automagically send wildmenu options without having to hit wildchar (tab)
      - then can fuzzy find vim menus hell yeaaaa
    - symbol/tag-tree hierarchical viewer (how does atom-ide do it? or other lang serv clients?)
      - vscode has started implementing this. i think there are corresponding LSP proposals
    - custom renderer (like custom ui for quickfix, etc.)
    - user configurable statusline
    - delay cmdline show if hide really quick to prevent flash - see #203 (https://github.com/veonim/veonim/issues/230)
    - helm discoverability menu or c-s-p fuzzy menu (i think i prefer the fuzzy, better for finding seldom used functions)
    - snippets (with the next extended marks feature coming soonª to neovim)

## grid dynamic resize (prolly not needed with fancy nvim window mgmt)

TODO: what if we could calculate availableColumns BEFORE hand?  it
should be deterministic based on the current grid size and
canvas-window paddings (how does this help?)

TODO: what if we apply a grid resize operation BEFORE the split
window event gets sent and processed. how could we intercept and
freeze split cmds?  api.getUserKeymap? listen for split key
events? WinNew autocmd?  if resize before, then there won't be a
need to wincmd = there will still be some shift, but maybe not
so much...

TODO: what if resize grid so it will always fit
n-windows + 1 that is, if there is only 1 window, the
grid will be resized to accomodate 2.  when 2 happen,
they will be resized for 3.
